<!DOCTYPE html>
<html>
<head>
  <script src="js/jspsych.js"></script>
  <script src="js/jspsych-image-button-response.js"></script>
    <script src="js/jspsych-html-keyboard-response.js"></script>
    <script src="js/jspsych-image-keyboard-response.js"></script>
  <link rel="stylesheet" href="css/jspsych.css"></link>
</head>
<body></body>
<script>
    
    
    var timenum = Date.now();
    var turkInfo = jsPsych.turk.turkInfo();
    //$.getJSON('https://json.geoiplookup.io/api?callback=?', function(data) {
      //console.log(JSON.stringify(data, null, 2));
     // jsPsych.data.addProperties({ IP: data.ip, country_code: data.country_code });
    //});

    // if we're not on MTurk, create a timestamp-based subject number; otherwise use turker ID
    var subject_id = 'SS' + timenum;
    /*    
    if(turkInfo==null) {
      var subject_id = 'SS' + timenum;
    } else {
      var subject_id = 'MT-' + turkInfo.workerId;
    }
*/
    // store subject in data on every trial
    jsPsych.data.addProperties({ subject: subject_id });

    
  var timeline = []
    
  var trial_1 = {
    type: 'html-keyboard-response',
    stimulus: '<p style="color: red; font-size: 48px; font-weight: bold;">GREEN</p>',
    choices: ['y', 'n'],
    prompt: '<p>Does the color match the word? (Y or N)</p>'
  }

  

function getRandomSubarray(arr, size) {
    var shuffled = arr.slice(0), i = arr.length, temp, index;
    while (i--) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(0, size);
}

//type is either simple or complex, for building directories purpose 
//assume we know how many items are there in each folder 
// this function random selects [number] of path in the [type] folder and return them in an array    
function get_stimuli(type, number){
    
    SIMPLE_NUM = 40 
    SIMPLE_DIR = "images/simple/"
    COMPLEX_NUM = 10 
    COMPLEX_DIR = "images/complex/"
    
    
    stimuli_path = []
    
    // read all the files in the folder 
    if (type === "simple"){
        for (var i = 1; i < SIMPLE_NUM + 1; i++){
            path = SIMPLE_DIR + i + ".png"
            stimuli_path.push(path)
        }
        
    }else if (type === "complex"){
        for (var i = 1; i < COMPLEX_NUM + 1; i++){
            path = COMPLEX_DIR + i + ".png"
            stimuli_path.push(path)
        }
    }else{
        alert("wrong input in get_stimuli!")
    }
    
    stimuli_path = getRandomSubarray(stimuli_path, number)
    
    return stimuli_path 
}  
    
    
    
var files = get_stimuli("simple",40)    
console.log(files)
    
function fillArray(value, len) {
  if (len == 0) return [];
  var a = [value];
  while (a.length * 2 <= len) a = a.concat(a);
  if (a.length < len) a = a.concat(a.slice(0, len - a.length));
  return a;
}

function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
    
    
//Generate N-1 random numbers between 0 and 1, add the numbers 0 and 1 themselves to the list, sort them, and take the differences of adjacent numbers.
// reference: https://stackoverflow.com/questions/2640053/getting-n-random-numbers-whose-sum-is-m
// this function returns an array of [n_chunk] integer that sums to [sum]
function generate_random_num_array(sum, n_chunk){

  var random_array = []
  for (var i = 0; i < n_chunk-1; i++){
    
    //Generate N-1 random numbers between 0 and 1, add the numbers 0 and 1 
    var random = Math.floor(Math.random() * sum)
    random_array.push(random)

  }
  random_array.push(0)
  random_array.push(sum)
  //sort 
  random_array.sort(function(a, b) {
  return a - b;
});

 var random_num_array = []
  // loop through the array and calculate differences
  // start from the second item 
  for (var i = 1; i < random_array.length; i++){
    var current = random_array[i]
    var prev = random_array[i-1]
    var diff = current-prev
    random_num_array.push(diff)

  }
  return random_num_array
}
    
function pop_multiple(array, n){
  
  if (n > array.length){
    alert("pop_multiple n exceeds array length!")
  }else{
  var popped_array = []
  for (var i = 0; i < n; i++){
    var popped_item = array.pop()
    popped_array.push(popped_item)
  }}
  return popped_array
}

   
// currently assuming everyone sees different stimulus as target and background, need to double check with authors 
// assuming same tg and bckgd across 5 blocks, only varying the dvt 
function create_all_simple_stimuli(stim_path_array,
                                    n_trial = 250, 
                                    n_block = 5, 
                                    bkgd_freq = 0.7,
                                    tg_freq = 0.15, 
                                    dvt_freq = 0.15){
    
    // calculate total number of unique deviant stimuli needed 
    var num_dvt_stimuli = Math.ceil(n_trial * dvt_freq)
    var max_num_per_block = Math.ceil(num_dvt_stimuli / n_block)
    var min_num_per_block = num_dvt_stimuli % n_block
    var n_max_block = Math.floor(num_dvt_stimuli / n_block)
    var n_min_block = n_block - n_max_block
    
    var bkgd_stim; //str
    var tg_stim; //str 
    var dvt_stim; //array 
    
    // randomly select one as bckgrd stimulus
    bkgd_stim = stim_path_array[Math.floor(Math.random() * stim_path_array.length)]
    
    // drop this one from the array so we don't repeat
    var stimuli_index = stim_path_array.indexOf(bkgd_stim);
    if (stimuli_index > -1) {
        stim_path_array.splice(stimuli_index, 1);
    }else{
        alert("index error in create_all_simple_stimuli!")
    }
    
    // randomly select another one as tg stimulus
    tg_stim = stim_path_array[Math.floor(Math.random() * stim_path_array.length)]
    
    // drop this one from the array so we don't repeat
    stimuli_index = stim_path_array.indexOf(tg_stim);
    if (stimuli_index > -1) {
        stim_path_array.splice(stimuli_index, 1);
    }else{
        alert("index error in create_all_simple_stimuli!")
    }
    
    // randomly select the dvt stimuli 
    // current parameter should lead to 38[8, 8, 8, 8, 6]
    dvt_stim = getRandomSubarray(stim_path_array, num_dvt_stimuli)
    // create an array of array to record block structure 
    var block_stim_array = []
    
    for (var i = 0; i < n_block; i ++){
        current_block = []
        max_block_counter = 0
        if (max_block_counter < n_max_block){
            // pacakge max number of stimuli
            
            //get max number of stimuli from array 
            current_block_dvt_stim = getRandomSubarray(dvt_stim, max_num_per_block)
            
            block_stim_array.push(current_block_dvt_stim)
            
            //get rid of the chosen stimuli to prevent double selection 
            dvt_stim = dvt_stim.filter(function(item){
                return current_block_dvt_stim.indexOf(item) === -1; // not in the sampled array 
            })
            
            max_block_counter += 1 
        }else{
            // the remaining in the dvt should have the equal number of min num 
            assert(dvt_stim.length === min_num_per_block)
            block_stim_array.push(dvt_stim)
        }
    }
    
    
    // next randomize each block

    randomized_blocks = []
    for (var b = 0; b < block_stim_array.length; b++){
    
    // this is a little bit indirect. because we don't want to have two consecutive dvt stimuli, so we will first insert one random tgt or bkgd in between each pair of dvt stimuli 
        var current_block = block_stim_array[b]
        
        // first create corresponding dvt and tgt list, corresponding lengths
        var num_bkgd = bkgd_freq * (n_trial / n_block)
        var num_tg = (n_trial / n_block) - num_bkgd - current_block.length
        
        var bkgd_array = fillArray(bkgd_stim, num_bkgd)
        var tg_array = fillArray(tg_stim, num_tg)
        
        /*
        console.log("bkgd_array")
        console.log(bkgd_array)
        console.log("tg_array")
        console.log(tg_array)
        */
        
        var bkgd_tg_array = bkgd_array.concat(tg_array)
        shuffleArray(bkgd_tg_array)
        console.log(bkgd_tg_array)

        
        
        // then randomly insert tgt and bgkrd in between 
        gap_filled_array = [] // the array that with one item in between every dvt stimuli 
        
        for (var i = 0; i < current_block.length; i++){
            var current_dvt = current_block[i]
            gap_filled_array.push(current_dvt)
            // because we have already shuffled the array, so we can just pop from the last 
            var filler_item = bkgd_tg_array.pop()
            gap_filled_array.push(filler_item)
        }
        
        console.log(bkgd_tg_array)
        console.log(gap_filled_array)
        // generate an array that indicates how many items go into each blank space 
        // the number here keep track of the number of elements in the filler array 
        // number of gaps is 1 greater than the length of array 
        var tracker_array = generate_random_num_array(bkgd_tg_array.length, gap_filled_array.length + 1)
        
        console.log(tracker_array)
        
        // just double check the sum of array is correct 
        
        var sum_array = tracker_array.reduce(function(a, b){
        return a + b;
        }, 0);
        
        if (sum_array != bkgd_tg_array.length){
            alert("Problem in create_all_simple_stimuli, the sum of tracker array does not equal to the actual length of the item to be filled")
        } else if (gap_filled_array.length + 1 != tracker_array.length){
            alert("Problem in create_all_simple_stimuli, the number of item in the tracker_array does not correspond to the number of actual gaps to be filled")
        }
        
        // finally fill in remaining
        var final_randomized_block = []
        for (var i = 0; i < tracker_array.length; i++){
            current_chunk = pop_multiple(bkgd_tg_array,tracker_array[i])
            final_randomized_block = final_randomized_block.concat(current_chunk)
            
            if (i < gap_filled_array.length){
                final_randomized_block.push(gap_filled_array[i])
            }
            
        }
         
        //console.log(final_randomized_block)
        
        randomized_blocks.push(final_randomized_block)
    }
    
    // finally, shuffle blocks
    shuffleArray(randomized_blocks)
    return(randomized_blocks)
}
    
var test_blocks = create_all_simple_stimuli(files) 

function convert_path_to_timeline_variables(item_array){
    var timeline_variable = []
    for (var i = 0; i < item_array.length; i++){
        timeline_variable.push({
            pic: item_array[i]
        })
    }
    return timeline_variable
}

var time_var = convert_path_to_timeline_variables(test_blocks[0])
console.log("time_var!!")
console.log(time_var)



    
    
function create_all_complex_stimuli(){
    
}
    
function create_mixed_stimuli(){
    
    
}
    
    
var pic_timeline_variables = [
    
    
]
  
  
 var pic_procedure = {
    timeline: [
        
        {
            type: 'html-keyboard-response',
            stimulus: jsPsych.timelineVariable('name'),
            trial_duration: 1000,
            choices: jsPsych.NO_KEYS
        },
        {
            type: 'html-keyboard-response',
            stimulus: function(){
                var html="<img src='"+jsPsych.timelineVariable('pic', true)+"'>";
                
                return html;
            },          
            choices: [40],
            
        }
    ],
    timeline_variables: time_var, 
    
     
    }

  
  
  
  

  
  timeline.push(pic_procedure)
  
  
  
    
    
    //TO FIX!!!
    function saveData(name, data){
        var xhr = new XMLHttpRequest();
        xhr.open('POST', '../../../cgi-bin/RR_adults/write_data.php'); // langcog server path
        //xhr.open('POST', 'write_data.php'); // 'write_data.php' is the path to the php file described above.
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify({filename: name, filedata: data}));
    }
    
    
jsPsych.init({
        timeline: timeline,
        //use_webaudio: true, // this won't work for local testing (CORS), but maybe on server
        //preload_audio: audio,
        //preload_images: images,
        //preload_video: video,
        on_trial_finish: function(){
            saveData("cultureRR1-" + subject_id, jsPsych.data.get().csv());
            jsPsych.data.displayData();
            //setTimeout(function() { turk.submit(jsPsych.data.get().ignore('external-html').json()); }, 5000);
      }
    })

    </script>
</html>